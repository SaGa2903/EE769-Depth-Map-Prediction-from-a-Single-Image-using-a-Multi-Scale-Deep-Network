# -*- coding: utf-8 -*-
"""Copy of Copy of Copy of Depth_Estimation_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D98NISovFlq2un1yOShK6FXGHBpVAPPu

# Depth Map Prediction from a Single Image using a Multi-Scale Deep Network
Pulkit Adil (200070062),
Akshay Verma (200070005),
Sahil Garg (200070070)

Depth estimation is a crucial task in computer vision, owing to its numerous applications in several fields. Depth estimation using stereo images has been extensively studied, but estimating the depth from a single image still remains an important challenge. This is due to the complexity of mapping 2d images to 3d images, and the lack of ground truth maps available for real-world images. A combination of coarse and fine-scale networks can be used to predict depth maps with high accuracy. The coarse network predicts the depth of the scene globally, while the fine-scale network refines the prediction locally to incorporate finer-scale details.

## Import Libraries
"""

# Commented out IPython magic to ensure Python compatibility.
import os

import pandas as pd

from tqdm.notebook import tqdm

import cv2

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.utils.data import Dataset
from torch.utils.data import DataLoader

from PIL import Image

import torchvision
from torchvision import models
import torchvision.transforms as transforms
from torchvision.utils import make_grid

import matplotlib.pyplot as plt
# %matplotlib inline

import numpy as np

"""# Download Dataset"""

!pip install opendatasets --upgrade --quiet

import opendatasets as od

dataset_url = 'https://www.kaggle.com/datasets/soumikrakshit/nyu-depth-v2'
od.download(dataset_url)

"""# Prepare Dataset
The following blocks of code prepare the training and test data for passing through the PyTorch sequential model.  
"""

train_dir = '/content/nyu-depth-v2/nyu_data'
test_dir = '/content/nyu-depth-v2/nyu_data'

train_csv1 = pd.read_csv('/content/nyu-depth-v2/nyu_data/data/nyu2_train.csv')
test_csv = pd.read_csv('/content/nyu-depth-v2/nyu_data/data/nyu2_test.csv')

train_csv = train_csv1[:9600]
# We use samples from training data folder itself for testing as the data in the test data folder was found to be corrupt
test_csv = train_csv1[9600:9728]

image_size = (228, 304)
depth_map_size = (55, 74)
batch_size = 128

"""Torch models require the data to be passed using a Dataloader object. Dataloader object in turn requires that the data be stored in an object of a class inherited from Dataset class."""

class DepthDataset(Dataset):
    def __init__(self, csv_file, root_dir, transform1, transform2):
        self.csv_file = csv_file
        self.root_dir = root_dir
        self.transform1 = transform1
        self.transform2 = transform2
        

    def __len__(self):
        return len(self.csv_file)
    
    def __getitem__(self, index):
        img_path = os.path.join(self.root_dir, self.csv_file.iloc[index, 0])
        image = Image.open(img_path).convert('RGB')
        depth_path = os.path.join(self.root_dir, self.csv_file.iloc[index, 1])
        depth_map = Image.open(depth_path).convert('L')

        image = self.transform1(image)
        depth_map = self.transform2(depth_map)

        return image, depth_map

# Image transforms for resizing and suitably changing images for model training and testing.
transform_img = transforms.Compose([transforms.Resize(image_size),
                                    transforms.CenterCrop(image_size),
                                    transforms.ToTensor()])

transform_depth = transforms.Compose([transforms.Resize(depth_map_size),
                                      transforms.CenterCrop(depth_map_size),
                                      transforms.ToTensor()])

# Create Dataset objects for training and testing respectively
train_ds = DepthDataset(train_csv, train_dir, transform_img, transform_depth)
test_ds = DepthDataset(test_csv, test_dir, transform_img, transform_depth)

# Dataloader objects for 
train_dl = DataLoader(train_ds, batch_size, shuffle = False, num_workers = 2, pin_memory = True)
test_dl = DataLoader(test_ds, 640, shuffle = False, num_workers = 2, pin_memory = True)

"""# Visualize Examples"""

def show_images(images, nmax=64):
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.set_xticks([]); ax.set_yticks([])
    ax.imshow(make_grid(images.detach()[:nmax], nrow=8).permute(1, 2, 0))

def show_dmaps(depth_maps, nmax=64):
    fig, ax = plt.subplots(figsize=(12, 12))
    ax.set_xticks([]); ax.set_yticks([])
    ax.imshow(make_grid(depth_maps.detach()[:nmax], nrow=8).permute(1, 2, 0), cmap='gray')

def show_batch(dl, nmax=64):
    for images, depth_maps in dl:
        show_images(images, nmax)
        show_dmaps(depth_maps, nmax)
        break

# show_batch(train_dl)

"""# Choosing device based on availability (GPU preferred)"""

def get_default_device():
    """Pick GPU if available, else CPU"""
    if torch.cuda.is_available():
        return torch.device('cuda')
    else:
        return torch.device('cpu')

device = get_default_device()
device

"""# Global Coarse-Scale Network Model
![coarse_network.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABKkAAACUCAYAAABY6HreAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAEd1SURBVHhe7Z0JmFTVtbZXTwxNd9M0dDOIgCCToqIiIFFRnGdxwNkEo6hRo0luNGqiZvDmXlTin5jcOItGROKAihMOOAMqCiqi4oAyNNDQzA09+te7qYNlpXqu6nOq+nufp57qOkNVdZ21z97r22utnfZdCBNCCCGEEEIIIYQQwkfSw89CCCGEEEIIIYQQQviGRCohhBBCCCGEEEII4TsSqYQQQgghhBBCCCGE70ikEkIIIYQQQgghhBC+I5FKCCGEEEIIIYQQQviORCohhBBCCCGEEEII4TsSqYQQQgghhBBCCCGE70ikEkIIIYQQQgghhBC+I5FKCCGEEEIIIYQQQviORCohhBBCCCGEEEII4TsSqYQQQgghhBBCCCGE70ikEkIIIYQQQgghhBC+I5FKCCGEEEIIIYQQQviORCohhBBCCCGEEEII4TsSqYQQQgghhBBCCCGE70ikEkIIIYQQQgghhBC+I5FKCCGEEEIIIYQQQviORCohhBBCCCGEEEII4TsSqYQQQgghhBBCCCGE76R9FyL8txBCCCGEEEIIIUTSsHHjRistLbWKigqrrKx0D8kcTSctLc2ysrLco23btlZQUGC5ubnhvYlHIpUQQgghhBBCCCGShm3bttny5ctt1apVtmbNGlu3bp1EqjgRS6QqLCx0j5133tltTyQSqYQQQgghhBBCCBF4EKCWLFliX3/9tS1dutRWr17txCmElOzsbGvTpo17ILSIpoFExG9aXl5uZWVlTgBs166dFRUVWe/eva1v377Ws2dPy8zMDJ8RXyRSCSGEEEIIIYQQItAglixYsMC++OILW7FiheXn51v37t2tc+fOLsqnffv2TqAi+kciVdOpqalxIhUPRCqEQNIp+c03b97sBCqEqqFDh1peXl74rPghkUoIIYQQQgghhBCBhaipefPm2cKFC50Y1atXL+vfv7/16NHDRVFlZGSEjxTxpqqqytauXetEqsWLF9u3337rItr22GMP23fffZ1QGE8kUgkhhBBCCCGEECKQIIq8/vrr9uWXX7qUs+HDhzuRiugp0bJQA+yrr76y999/3wlXCIWjR492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)
"""

class CoarseNetwork(nn.Module):
    def __init__(self):
        super().__init__()
        self.network = nn.Sequential(
            # in: 3 x 228 x 304

            nn.Conv2d(3, 96, kernel_size = 11, stride = 4),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),
            # out: 96 x 27 x 37

            nn.Conv2d(96, 256, kernel_size = 5, padding = 2),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),
            # out: 256 x 13 x 18

            nn.Conv2d(256, 384, kernel_size = 3, padding = 1),
            nn.ReLU(),
            # out: 384 x 13 x 18

            nn.Conv2d(384, 384, kernel_size = 3, padding = 1),
            nn.ReLU(),
            # out: 384 x 13 x 18

            nn.Conv2d(384, 256, kernel_size = 3, stride = 2),
            nn.ReLU(),
            # out: 256 x 6 x 8

            nn.Flatten(1, 3),
            nn.Linear(256*6*8, 4096),
            nn.ReLU(),

            nn.Dropout(0.2),
            nn.Linear(4096, 4070),
            # nn.Sigmoid()
        )

    def forward(self, img):
        bs = img.size(0)
        coarse = self.network(img)#[:,:4070]
        return torch.reshape(coarse, (bs, 1, 55, 74))

coarse_model = CoarseNetwork()

"""# Local Fine-Scale Network
![fine_layer.png](data:image/png;base64,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)
"""

class FineNetwork(nn.Module):
    
    def __init__(self):
        super().__init__()
        self.network1 = nn.Sequential(
            # in: 3 x 304 x 228

            nn.Conv2d(3, 63, kernel_size = 9, stride = 2),
            nn.ReLU(),
            nn.MaxPool2d(2, 2),
            # out: 63 x 74 x 55  
        )
        self.network2 = nn.Sequential(
            # in: 64 x 74 x 55

            nn.Conv2d(64, 64, kernel_size = 5, padding = 2),
            nn.ReLU(),
            # out: 64 x 74 x55

            nn.Conv2d(64, 1, kernel_size = 5, padding = 2),
            # out: 1 x 74 x 55

            # nn.Sigmoid()
        )
            
    def forward(self, img, coarse):
        fine = self.network1(img)
        fine = torch.cat((fine, coarse), dim = 1)
        return self.network2(fine)

fine_model = FineNetwork()

"""# Loss Function

"""

# Total no. of pixels in the final output images
n = 74 * 55

"""As described in the research paper we've used the following scale invariant mean squared error (log scale) as the metric for comparing performance in addition to the standard RMSE:

\begin{equation} 
D(y,y^*) = \frac{1}{n} \sum_{i} d_i^2 - \frac{1}{n^2} (\sum_{i} d_i)^2
\end{equation}

where $d_i = \log y_i - \log y^*_i$ $\forall i\in\{1,\cdots,n\}$. 

The following loss function derived from the above mentioned scale invariant error is used for training.

\begin{equation} 
L(y,y^*, \lambda) = \frac{1}{n} \sum_{i} d_i^2 - \frac{\lambda}{n^2} (\sum_{i} d_i)^2
\end{equation}

with $d_i$'s as defined before and the default value of $\lambda$ being 0.5. For the scale invariant error, the loss function can be called with $\lambda=1$.
"""

def train_loss(pred, target, lmbda=0.5):

    di = pred - torch.log(target+1e-10)
    di2 = torch.square(di)

    error = torch.sum(di2/n, (1, 2, 3)) - lmbda*torch.square(torch.sum(di/n, (1, 2, 3)))
    return error.mean()

"""# Training The Coarse Network
We've trained the model on only 4 epochs because the training dataset consists of high-resolution images and the size of our neural network is also large. All attempts at training for higher epochs resulted in a "CUDA memory limit exceeded error" and eventually resulting in exhaustion of limits on usage of the GPU available on colab.
"""

# no. of epochs kept low due to CUDA usage limitations 
epochs = 4

# learning rate                                                                      
lr = 0.0001

def train_coarse(epochs, lr, coarse_model, train_dl, opt_func = torch.optim.Adam):
    optimizer = opt_func(coarse_model.parameters(), lr)

    # Load the model into the GPU
    coarse_model = coarse_model.to(device)

    coarse_model.train()

    for epoch in range(epochs):
        coarse_losses = []
        for imgs, dmaps in tqdm(train_dl):

            # Move data into the GPU
            imgs = imgs.to(device)
            dmaps = dmaps.to(device)
            
            preds = coarse_model(imgs)

            loss = train_loss(preds, dmaps)
            coarse_losses.append(loss)
            
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            torch.cuda.empty_cache()

        coarse_losses = torch.Tensor(coarse_losses)
        avg_loss = torch.mean(coarse_losses)
        print('Loss: ' + str(avg_loss))

train_coarse(epochs, lr, coarse_model, train_dl)

"""# Training The Fine Network"""

def train_fine(epochs, lr, fine_model, train_dl, opt_func = torch.optim.Adam):
    optimizer = opt_func(fine_model.parameters(), lr)

    # Load the model into the GPU
    fine_model = fine_model.to(device)

    fine_model.train()
    coarse_model.eval()

    for epoch in range(epochs):
        fine_losses = []
        for imgs, dmaps in tqdm(train_dl):

            # Move data into the GPU
            imgs = imgs.to(device)
            dmaps = dmaps.to(device)

            # giving the coarse network output as input to the fine network
            coarse_outputs = coarse_model(imgs)
            coarse_outputs = coarse_outputs.to(device)

            preds = fine_model(imgs, coarse_outputs)
            loss = train_loss(preds, dmaps)

            fine_losses.append(loss)
            
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

            torch.cuda.empty_cache()

        fine_losses = torch.Tensor(fine_losses)
        avg_loss = torch.mean(fine_losses)
        print('Loss: ' + str(avg_loss))

train_fine(epochs, lr, fine_model, train_dl)

"""# Results on test data"""

def evaluate(coarse_model, fine_model, test_dl):
    errors = []
    si_errors = []
    rmse_errors = []
    
    # list for storing coarse layer output predictions (batch-wise)
    coarse_outputs_list = []

    # list for storing fine layer output predictions (batch-wise)
    fine_outputs_list = []

    for imgs, dmaps in tqdm(test_dl):
        imgs = imgs.to(device)
        dmaps = dmaps.to(device)

        # coarse layer outputs for a batch
        coarse_outputs = coarse_model(imgs)
        coarse_outputs_list.append(torch.exp(coarse_outputs))

        # fine layer outputs for a batch
        preds = fine_model(imgs, coarse_outputs)
        fine_outputs_list.append(torch.exp(preds))

        # training loss value for a batch
        error = train_loss(preds, dmaps)
        
        # scale-invariant error for a batch
        si_error = train_loss(preds, dmaps, 1)

        # rmse error for a batch 
        rmse_error = torch.sqrt(nn.MSELoss()(preds, dmaps))

        errors.append(error)
        si_errors.append(si_error)
        rmse_errors.append(rmse_error)

    errors = torch.Tensor(errors)
    si_errors = torch.Tensor(si_errors)
    rmse_errors = torch.Tensor(rmse_errors)

    # evaluating average errors
    avg_error = torch.mean(errors)
    avg_si_error = torch.mean(si_errors)
    avg_rmse_error = torch.mean(rmse_errors)

    print('error: {}, scale invariant error: {}, root mean squared error: {}'.format(avg_error, avg_si_error, avg_rmse_error))

    return coarse_outputs_list, fine_outputs_list

# evaluating the model on test data
batch_coarse_outputs, batch_fine_outputs = evaluate(coarse_model, fine_model, test_dl)

# list for storing coarse network output images
coarse_output_images = []
for i in range(1):
    for j in range(128):
        coarse_output_images.append(batch_coarse_outputs[i].cpu()[j,:,:,:].detach().numpy())

# list for storing fine layer output images
fine_output_images = []
for i in range(1):
    for j in range(128):
        fine_output_images.append(batch_fine_outputs[i].cpu()[j,:,:,:].detach().numpy())

# displaying sample coarse and fine layer output images
from google.colab.patches import cv2_imshow as imshow
i = 0
imshow(np.transpose(255*coarse_output_images[i]/np.max(coarse_output_images[i]),(1,2,0)))
imshow(np.transpose(155*fine_output_images[i]/np.max(fine_output_images[i]),(1,2,0)))

# displaying the first 8 images from the list
images = []
for i in range(8):
  for im, depth in test_dl:
      img = np.transpose(np.array(im.detach()[i]), (1,2,0))
      images.append(img*255)
      break

# creating a horizontal stack of images to be shown
pad = np.ones((images[0].shape[0], 5, 3))*255
stack = np.hstack((images[0], pad, images[1], pad, images[2], pad, images[3], pad, images[4], pad, images[5], pad, images[6], pad, images[7]))

imshow(stack)

# displaying the ground truth depth maps of the above images
depths = []
for i in range(8):
  for im, depth in test_dl:
      dp = np.transpose(np.array(depth.detach()[i]), (1,2,0))
      depths.append(dp*255/np.max(dp))
      break

# creating a horizontal stack of images to be shown
pad = np.ones((depths[0].shape[0], 5, 1))*255
stack = np.hstack((depths[0], pad, depths[1], pad, depths[2], pad, depths[3], pad, depths[4], pad, depths[5], pad, depths[6], pad, depths[7]))

imshow(stack)

# displaying the coarse and coarse+fine network prdictions for the above images
coarse = []
fine = []
for i in range(8):
  coarse.append(np.transpose(255*coarse_output_images[i]/np.max(coarse_output_images[i]),(1,2,0)))
  fine.append(np.transpose(255*fine_output_images[i]/np.max(fine_output_images[i]),(1,2,0)))

# creating a horizontal stack of images to be shown
pad = np.ones((coarse_output_images[0].shape[1], 1, 1))
stack_coarse = np.hstack((coarse[0], pad, coarse[1], pad, coarse[2], pad, coarse[3], pad, coarse[4], pad, coarse[5], pad, coarse[6], pad, coarse[7]))
stack_fine = np.hstack((fine[0], pad, fine[1], pad, fine[2], pad, fine[3], pad, fine[4], pad, fine[5], pad, fine[6], pad, fine[7]))

imshow(stack_coarse)
imshow(stack_fine)